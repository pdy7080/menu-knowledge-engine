"""
Production DB Sync
로컬 스테이징 데이터 → FastComet PostgreSQL 프로덕션 DB 동기화

Strategy:
1. 스테이징 디렉토리에서 새 메뉴/콘텐츠/이미지 데이터 로드
2. 프로덕션 DB에 INSERT/UPDATE
3. 동기화 상태 추적

Author: terminal-developer
Date: 2026-02-20
"""

import json
import logging
from datetime import datetime
from pathlib import Path
from typing import Dict, Any

from .state_manager import StateManager
from .config_auto import auto_settings

logger = logging.getLogger("automation.sync")


def _sanitize_value(value) -> str:
    """None, 'None', 빈 값을 SQL-safe 문자열로 변환"""
    if value is None:
        return ""
    s = str(value).strip()
    if s.lower() in ("none", "null", "n/a"):
        return ""
    return s


class ProductionSync:
    """프로덕션 DB 동기화"""

    def __init__(self):
        self.state = StateManager("sync")
        self.staging_dir = Path(auto_settings.AUTOMATION_STAGING_DIR)

    async def sync_all(self) -> Dict[str, Any]:
        """전체 동기화 실행"""
        self.state.start_run()
        result = {
            "menus_synced": 0,
            "content_synced": 0,
            "images_synced": 0,
            "errors": [],
            "completed_at": datetime.now().isoformat(),
        }

        prod_url = auto_settings.PRODUCTION_DATABASE_URL
        if not prod_url:
            logger.warning("PRODUCTION_DATABASE_URL not configured, using export mode")
            result = await self._export_for_manual_sync()
        else:
            result = await self._direct_sync(prod_url)

        self.state.end_run(
            result.get("menus_synced", 0),
            len(result.get("errors", [])),
        )
        return result

    async def _export_for_manual_sync(self) -> Dict[str, Any]:
        """
        직접 연결 불가 시 SQL 파일로 내보내기
        서버에서 수동 실행할 수 있는 INSERT 문 생성
        """
        result = {
            "menus_synced": 0,
            "content_synced": 0,
            "images_synced": 0,
            "errors": [],
        }

        # 스테이징 데이터 수집
        new_menus_dir = self.staging_dir / "new_menus"
        export_dir = self.staging_dir / "export"
        export_dir.mkdir(parents=True, exist_ok=True)

        # enriched 데이터 로드 (name_en + content)
        enriched_map = self._load_enriched_data()

        sql_lines = []
        sql_lines.append("-- Auto-generated by Menu Automation System")
        sql_lines.append(f"-- Date: {datetime.now().isoformat()}")
        sql_lines.append("-- Run this on production PostgreSQL\n")
        sql_lines.append("BEGIN;\n")

        # 1. 새 메뉴 INSERT (enriched name_en 포함)
        if new_menus_dir.exists():
            for json_file in sorted(new_menus_dir.glob("discovery_*.json")):
                try:
                    with open(json_file, "r", encoding="utf-8") as f:
                        data = json.load(f)

                    for menu in data.get("menus", []):
                        name_ko = _sanitize_value(menu.get("name_ko", ""))
                        if not name_ko:
                            continue

                        # enriched에서 name_en 우선 가져오기
                        enriched = enriched_map.get(name_ko, {})
                        name_en = _sanitize_value(
                            enriched.get("name_en") or menu.get("name_en", "")
                        )
                        category = _sanitize_value(menu.get("category_hint", ""))

                        # dollar-quoting: 단따옴표 인젝션 방지
                        sql_lines.append(
                            f"INSERT INTO canonical_menus (id, name_ko, name_en, status, category_1) "
                            f"VALUES (gen_random_uuid(), $q${name_ko}$q$, $q${name_en}$q$, 'active', $q${category}$q$) "
                            f"ON CONFLICT (name_ko) DO NOTHING;"
                        )
                        result["menus_synced"] += 1

                except Exception as e:
                    result["errors"].append(str(e))

        # 2. Enriched 콘텐츠 UPDATE (enrichment_batch_*.json에서)
        for name_ko, enriched in enriched_map.items():
            try:
                content = enriched.get("content", {})
                if not content:
                    continue

                name_en = _sanitize_value(enriched.get("name_en", ""))
                desc_ko = _sanitize_value(content.get("description_ko", ""))
                desc_en = _sanitize_value(content.get("description_en", ""))
                content_json = json.dumps(content, ensure_ascii=False)

                # dollar-quoting: 단따옴표/특수문자 인젝션 방지
                sql_lines.append(
                    f"UPDATE canonical_menus SET "
                    f"name_en = $q${name_en}$q$, "
                    f"description_long_ko = $q${desc_ko}$q$, "
                    f"description_long_en = $q${desc_en}$q$, "
                    f"enriched_content = $q${content_json}$q$::jsonb "
                    f"WHERE name_ko = $q${name_ko}$q$;"
                )
                result["content_synced"] += 1

            except Exception as e:
                result["errors"].append(str(e))

        sql_lines.append("\nCOMMIT;")

        # SQL 파일 저장
        export_file = export_dir / f"sync_{datetime.now().strftime('%Y%m%d_%H%M')}.sql"
        with open(export_file, "w", encoding="utf-8") as f:
            f.write("\n".join(sql_lines))

        logger.info(f"Export SQL saved: {export_file}")
        logger.info(f"  Menus: {result['menus_synced']}")
        logger.info(f"  Content: {result['content_synced']}")

        result["export_file"] = str(export_file)
        result["completed_at"] = datetime.now().isoformat()
        return result

    def _load_enriched_data(self) -> Dict[str, Dict]:
        """
        스테이징에서 enriched 데이터 로드
        enrichment_batch_*.json 파일들을 name_ko 기준으로 병합

        Returns:
            {name_ko: {name_en, content, ...}} 매핑
        """
        enriched_map: Dict[str, Dict] = {}

        # enrichment_batch_*.json은 staging 루트에 저장됨
        for json_file in sorted(self.staging_dir.glob("enrichment_batch_*.json")):
            try:
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)

                menus = data.get("menus", [])
                for menu in menus:
                    name_ko = _sanitize_value(menu.get("name_ko", ""))
                    if name_ko:
                        enriched_map[name_ko] = menu

            except Exception as e:
                logger.warning(f"Failed to load enriched data from {json_file}: {e}")

        logger.info(f"Loaded enriched data: {len(enriched_map)} menus")
        return enriched_map

    async def _direct_sync(self, prod_url: str) -> Dict[str, Any]:
        """프로덕션 DB에 직접 연결하여 동기화"""
        result = {
            "menus_synced": 0,
            "content_synced": 0,
            "images_synced": 0,
            "errors": [],
        }

        try:
            from sqlalchemy.ext.asyncio import (
                create_async_engine,
                async_sessionmaker,
                AsyncSession,
            )
            from sqlalchemy import text

            # PostgreSQL URL 변환
            if prod_url.startswith("postgresql://"):
                prod_url = prod_url.replace("postgresql://", "postgresql+asyncpg://")

            engine = create_async_engine(prod_url, echo=False)
            SessionLocal = async_sessionmaker(
                engine, class_=AsyncSession, expire_on_commit=False
            )

            # 스테이징 데이터 로드
            new_menus_dir = self.staging_dir / "new_menus"

            async with SessionLocal() as session:
                if new_menus_dir.exists():
                    for json_file in sorted(new_menus_dir.glob("discovery_*.json")):
                        try:
                            with open(json_file, "r", encoding="utf-8") as f:
                                data = json.load(f)

                            for menu in data.get("menus", []):
                                name_ko = menu.get("name_ko", "")
                                name_en = menu.get("name_en", "") or ""

                                # 중복 확인
                                check = await session.execute(
                                    text(
                                        "SELECT id FROM canonical_menus WHERE name_ko = :name"
                                    ),
                                    {"name": name_ko},
                                )
                                if check.fetchone():
                                    continue

                                await session.execute(
                                    text(
                                        "INSERT INTO canonical_menus (id, name_ko, name_en, status) "
                                        "VALUES (gen_random_uuid(), :name_ko, :name_en, 'active')"
                                    ),
                                    {"name_ko": name_ko, "name_en": name_en},
                                )
                                result["menus_synced"] += 1

                        except Exception as e:
                            result["errors"].append(str(e))

                await session.commit()

            await engine.dispose()
            logger.info(f"Direct sync: {result['menus_synced']} menus synced")

        except ImportError:
            logger.error("asyncpg not installed for direct sync")
            result = await self._export_for_manual_sync()
        except Exception as e:
            logger.error(f"Direct sync failed: {e}")
            logger.info("Falling back to export mode")
            result = await self._export_for_manual_sync()

        result["completed_at"] = datetime.now().isoformat()
        return result
